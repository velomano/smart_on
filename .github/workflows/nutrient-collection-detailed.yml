name: 영양액 레시피 자동 수집 (세부)

on:
  schedule:
    - cron: '0 */6 * * *'   # 6시간마다 실행 (00:00, 06:00, 12:00, 18:00)
  workflow_dispatch:
    inputs:
      source:
        description: '수집할 소스 (all, cornell, rda, fao, academic)'
        required: false
        default: 'all'
        type: string
      batch_size:
        description: '배치 크기'
        required: false
        default: '50'
        type: string

jobs:
  collect-recipes:
    runs-on: ubuntu-latest

    env:
      SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
      SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
      TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
      TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      SOURCE: ${{ inputs.source || 'all' }}
      BATCH_SIZE: ${{ inputs.batch_size || '10' }}

    steps:
    - name: 체크아웃
      uses: actions/checkout@v4

    - name: Node.js 설정
      uses: actions/setup-node@v4
      with:
        node-version: '20'

    - name: 의존성 설치
      run: |
        cd apps/worker
        npm install

    - name: TypeScript 컴파일
      run: |
        cd apps/worker
        npm run build

    - name: 영양액 레시피 수집 및 crop_profiles 저장
      run: |
        set -euo pipefail
        
        cd apps/worker
        
        SUPA_URL="${SUPABASE_URL:-***}"
        SUPA_KEY="${SUPABASE_SERVICE_ROLE_KEY:-test-key}"
        SRC="${SOURCE:-all}"
        BATCH="${BATCH_SIZE:-10}"
        
        echo "🚀 영양액 레시피 수집 시작 (소스: ${SRC}, 배치: ${BATCH})"
        
        # 환경변수 설정
        export SUPABASE_URL="$SUPA_URL"
        export SUPABASE_SERVICE_ROLE_KEY="$SUPA_KEY"
        
        # 실제 수집 및 nutrient_recipes 직접 저장
        node -e "
        const { collectAllRecipes } = require('./dist/sources/all.js');
        
        async function main() {
          try {
            console.log('🌱 실제 수집 시작...');
            const recipes = await collectAllRecipes($BATCH);
            console.log(\`📊 수집 완료: \${recipes.length}건\`);
            
            // 수집 건수를 환경변수로 설정 (텔레그램 알림용)
            process.env.COLLECTED_COUNT = recipes.length.toString();
            
            // nutrient_recipes 형식으로 변환하여 직접 저장
            let savedCount = 0;
            for (const recipe of recipes) {
              const source = recipe.source;
              
              // macro/micro 데이터를 target_ppm 형식으로 변환
              const targetPpm = {
                N: recipe.macro?.N || 0,
                P: recipe.macro?.P || 0,
                K: recipe.macro?.K || 0,
                Ca: recipe.macro?.Ca || 0,
                Mg: recipe.macro?.Mg || 0,
                S: recipe.macro?.S || 0
              };
              
              // NPK 비율 계산
              const npkRatio = \`\${targetPpm.N}:\${targetPpm.P}:\${targetPpm.K}\`;
              
              // 환경 조건 정보 생성
              const growingConditions = {
                temperature: \`\${recipe.env?.temp || 20}°C\`,
                humidity: \`\${recipe.env?.humidity || 65}%\`,
                light_hours: \`\${Math.round((recipe.env?.lux || 15000) / 1000)}시간\`,
                co2_level: '800-1200ppm'
              };
              
              // 영양소 상세 정보 생성
              const nutrientsDetail = {
                nitrogen: targetPpm.N,
                phosphorus: targetPpm.P,
                potassium: targetPpm.K,
                calcium: targetPpm.Ca,
                magnesium: targetPpm.Mg,
                trace_elements: ['Fe', 'Mn', 'B', 'Zn', 'Cu', 'Mo']
              };
              
              // 사용법 및 주의사항
              const usageNotes = [
                '주 1회 EC 측정 권장',
                'pH는 6.0-6.5 범위 유지',
                '온도가 높을 때는 EC를 낮춰 사용'
              ];
              
              const warnings = [
                '칼슘 결핍 시 잎 끝 갈변 현상',
                '과도한 질소는 과번무 유발'
              ];
              
              // nutrient_recipes 형식으로 변환
              const micro = {
                Fe: recipe.micro?.Fe || 2,
                Mn: recipe.micro?.Mn || 0.5,
                B: recipe.micro?.B || 0.5,
                Zn: recipe.micro?.Zn || 0.1,
                Cu: recipe.micro?.Cu || 0.05,
                Mo: recipe.micro?.Mo || 0.05
              };
              
              const nutrientRecipe = {
                crop_key: recipe.crop_key,
                stage: recipe.stage,
                target_ec: recipe.target_ec,
                target_ph: recipe.target_ph,
                macro: targetPpm,
                micro: micro,
                source_id: null, // source_id는 별도로 처리 필요
                reliability: source?.reliability_default || 0.7,
                checksum: \`\${recipe.crop_key}_\${recipe.stage}_\${source?.name || 'unknown'}_\${Date.now()}_\${Math.random().toString(36).substr(2, 9)}\`
              };
              
              // nutrient_recipes에 직접 저장 (자동 수집용)
              const res = await fetch(process.env.SUPABASE_URL + '/rest/v1/nutrient_recipes', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'apikey': process.env.SUPABASE_SERVICE_ROLE_KEY,
                  'Authorization': \`Bearer \${process.env.SUPABASE_SERVICE_ROLE_KEY}\`,
                  'Prefer': 'resolution=merge-duplicates'
                },
                body: JSON.stringify(nutrientRecipe)
              });
              
              if (res.ok) {
                savedCount++;
                console.log(\`✅ 저장 완료: \${recipe.crop_name} (\${recipe.stage}) - \${source?.name || 'Unknown'}\`);
              } else {
                const errorText = await res.text();
                console.error(\`❌ 저장 실패: \${recipe.crop_name}\`, errorText);
              }
            }
            
            console.log(\`🎉 저장 완료: \${savedCount}/\${recipes.length}건\`);
            
            // 저장 건수를 환경변수로 설정 (텔레그램 알림용)
            process.env.SAVED_COUNT = savedCount.toString();
            process.env.TOTAL_COUNT = recipes.length.toString();
            
            // 수집 통계 출력
            const sourceStats = recipes.reduce((acc, recipe) => {
              const sourceName = recipe.source?.name || 'Unknown';
              acc[sourceName] = (acc[sourceName] || 0) + 1;
              return acc;
            }, {});
            
            console.log('📈 수집 통계:');
            Object.entries(sourceStats).forEach(([source, count]) => {
              console.log(\`  - \${source}: \${count}건\`);
            });
            
          } catch (error) {
            console.error('💥 수집 실패:', error);
            process.exit(1);
          }
        }
        
        main();
        "

    - name: 수집 결과 텔레그램 알림
      if: always() && env.TELEGRAM_BOT_TOKEN != '' && env.TELEGRAM_CHAT_ID != ''
      run: |
        STATUS="${{ job.status }}"
        SOURCE="${{ env.SOURCE }}"
        TRIGGER="${{ github.event_name }}"
        
        # 수집 결과 정보 설정
        if [ "$STATUS" = "success" ]; then
          ICON="✅"
          MESSAGE="영양액 레시피 수집 작업이 성공적으로 완료되었습니다!"
          
          # 기본 정보 (실제 수집 결과는 로그에서 확인)
          COLLECTED_INFO="📊 <b>수집 결과</b>: 성공적으로 완료"
          SAVED_INFO="💾 <b>상태</b>: 데이터베이스에 저장됨"
        else
          ICON="❌"
          MESSAGE="영양액 레시피 수집 작업이 실패했습니다."
          COLLECTED_INFO="📊 <b>수집 결과</b>: 실패"
          SAVED_INFO="💾 <b>상태</b>: 저장되지 않음"
        fi
        
        FULL_MESSAGE="$ICON <b>스마트팜 영양액 수집 알림</b>

        📊 <b>작업 상태</b>: $STATUS
        🌱 <b>수집 소스</b>: $SOURCE
        ⏰ <b>실행 시간</b>: $(date '+%Y-%m-%d %H:%M:%S')
        🔄 <b>트리거</b>: $TRIGGER
        $COLLECTED_INFO
        $SAVED_INFO
        
        $MESSAGE"
        
        curl -s -X POST "https://api.telegram.org/bot${{ env.TELEGRAM_BOT_TOKEN }}/sendMessage" \
          -H "Content-Type: application/json" \
          -d "{
            \"chat_id\": \"${{ env.TELEGRAM_CHAT_ID }}\",
            \"text\": \"$FULL_MESSAGE\",
            \"parse_mode\": \"HTML\"
          }"
